#!/usr/bin/env python
import sys
import os
import fnmatch
import bsddb
import ujson

from clang.cindex import Index, TranslationUnit, CursorKind
from optparse import OptionParser, OptionGroup

class SourceFile:
    def __init__(self):
        self.extensions = ['*.c', '*.h', '*.C', '*.H',
                           '*.c++', '*.cc', '*.cp', '*.cpp', '*.cxx',
                           '*.h++', '*.hh', '*.hp', '*.hpp', '*.hxx']

    def locate(self, root):
        '''Locate all C/C++ files matching extensions attribute.
        '''
        for path, dirs, files in os.walk(os.path.relpath(root)):
            for extension in self.extensions:
                for filename in fnmatch.filter(files, extension):
                    yield os.path.join(os.path.relpath(path), filename)


class TagDB:
    def __init__(self, outputFile='tags.db'):
        self.db = bsddb.btopen(outputFile, 'c')

    def __del__(self):
        self.db.sync()
        self.db.close()

    def persist(self, ast):
        for key,value in ast.iteritems():
            if not self.db.has_key(key):
                self.db[key] = ujson.dumps(value)


class Options:
    def __init__(self):
        self.autoInclude = True
        self.showIDs = False
        self.verbose = False
        self.maxDepth = 0
        self.outputFile = 'tags.db'


class Crange:
    "Class Crange"

    def __init__(self):
        self.opts = Options()
        self.args = list()
        self.ast  = list()
        
    def debug(self, message):
        if self.opts.verbose:
            print message

    def get_diag_info(self, diag):
        return { 'severity' : diag.severity,
                 'location' : diag.location,
                 'spelling' : diag.spelling,
                 'ranges' : diag.ranges,
                 'fixits' : diag.fixits }

    def get_cursor_id(self, cursor, cursor_list = []):
        if not self.opts.showIDs:
            return None
                
        if cursor is None:
            return None

        # FIXME: This is really slow. It would be nice if the index API exposed
        # something that let us hash cursors.
        for i,c in enumerate(cursor_list):
            if cursor == c:
                return i
        cursor_list.append(cursor)
        return len(cursor_list) - 1
    
    # Node's hash key reference:
    #  l  : location line number
    #  c  : location column number
    #  o  : location offset
    #  sl : extent start line
    #  sc : extent start column
    #  el : extent end line
    #  ec : extent end column
    #  k  : node kind name
    #  t  : node type name
    #  s  : spelling
    #  d  : display
    #  d? : node is a definition?
    #  df : USR of node's definition.
    #  s? : node is a static method?
    #  r? : node is a reference?
    #  r  : USR of node's that is referenced.
    #  u  : USR of this node.
    #
    def get_info(self, node, depth=0):
        if self.opts.maxDepth is not None and depth >= self.opts.maxDepth:
            children = None
        else:
            children = [self.get_info(c, depth+1)
                        for c in node.get_children()]
        loc = str(node.location.file) if node.location.file else None
        n = {'l' : node.location.line,
             'c' : node.location.column,
             'o' : node.location.offset,
             'sl' : node.extent.start.line,
             'sc' : node.extent.start.column,
             'el' : node.extent.end.line,
             'ec' : node.extent.end.column,
             'k' : node.kind.name,
             't' : node.type.kind.name,
             's' : node.spelling,
             'd' : node.displayname,
             'd?' : node.is_definition(),
             'df' : node.get_definition().get_usr() if node.get_definition() else None,
             's?' : node.is_static_method(),
             'r?' : node.kind.is_reference(),
             'r' : node.referenced.get_usr() if node.referenced else None,
             'u' : node.get_usr() }
        if loc not in self.ast:
            self.ast[loc] = list()
        if loc is not None:
            self.ast[loc].append(n)


    def generate(self, root):
        sfo   = SourceFile()
        tagdb = TagDB(self.opts.outputFile)
        index = Index.create()
        for source in sfo.locate(root):
            self.ast = {}
            clang_line = [source, '-Iinclude']
            self.debug(' '.join(clang_line))
            tu = index.parse(None, clang_line)
            self.get_info(tu.cursor)
            tagdb.persist(self.ast)

if __name__ == '__main__':
    c=Crange()

    parser = OptionParser("usage: %prog [options] {directory} [clang-args*]")
    parser.add_option("-a", "--auto-include", dest="autoInclude",
                      help="Automatically detect and add include paths (-Isrc/include).",
                      default=False, action="store_true")
    parser.add_option("-i", "--show-ids", dest="showIDs",
                      help="Don't compute cursor IDs (very slow)",
                      default=False, action="store_true")
    parser.add_option("-d", "--max-depth", dest="maxDepth",
                      help="Limit cursor expansion to depth N",
                      metavar="N", type="int", default=None)
    parser.add_option("-o", "--output", dest="outputFile",
                      help="Write tags to FILE",
                      metavar="FILE", type="string", default="tags.db")
    parser.add_option("-v", "--verbose", dest="verbose",
                      help="Verbose mode",
                      default=False, action="store_true")
    parser.disable_interspersed_args()
    (c.opts, c.args) = parser.parse_args()

    if len(c.args) == 0:
        parser.error('Invalid number of arguments')

    if os.path.isdir(c.args[0]):
        c.generate(c.args[0])
    else:
        parser.error("%s is not a directory" % c.args[0])
