#!/usr/bin/env python
import sys
import ujson

from clang.cindex import Index, TranslationUnit, CursorKind
from pprint import pprint
from blist import blist
from optparse import OptionParser, OptionGroup

class Options:
    def __init__(self):
        self.showIDs = None
        self.maxDepth = 0


class Crange:
    "Class Crange"

    def __init__(self):
        self.ast = list()
        self.opts = Options()

    def get_diag_info(self, diag):
        return { 'severity' : diag.severity,
                 'location' : diag.location,
                 'spelling' : diag.spelling,
                 'ranges' : diag.ranges,
                 'fixits' : diag.fixits }

    def get_cursor_id(self, cursor, cursor_list = []):
        if not self.opts.showIDs:
            return None
                
        if cursor is None:
            return None

        # FIXME: This is really slow. It would be nice if the index API exposed
        # something that let us hash cursors.
        for i,c in enumerate(cursor_list):
            if cursor == c:
                return i
        cursor_list.append(cursor)
        return len(cursor_list) - 1
    
    def get_info(self, node, depth=0):
        if self.opts.maxDepth is not None and depth >= self.opts.maxDepth:
            children = None
        else:
            children = [self.get_info(c, depth+1)
                        for c in node.get_children()]
        n = {'loc'      : str(node.location.file) if node.location.file else None,
            'loc.line' : node.location.line,
            'loc.col'  : node.location.column,
            'loc.offset' : node.location.offset,
            'extent.start.line': node.extent.start.line,
            'extent.start.col' : node.extent.start.column,
            'extent.end.line'  : node.extent.end.line,
            'extent.end.col'   : node.extent.end.column,
            'kind'     : node.kind.name,
            'type'     : node.type.kind.name,
            'spelling' : node.spelling,
            'display'  : node.displayname,
            'def?'     : node.is_definition(),
            'def' : node.get_definition().get_usr() if node.get_definition() else None,
            'static?'  : node.is_static_method(),
            'ref?'     : node.kind.is_reference(),
            'ref'      : node.referenced.get_usr() if node.referenced else None,
            'usr'      : node.get_usr()}
        self.ast.append(n)

    def generate(self, args):
        index = Index.create()
        tu = index.parse(None, args)
        self.get_info(tu.cursor)
        f=open('tags.json', 'w')
        f.write(ujson.dumps(self.ast))
        f.close
        

if __name__ == '__main__':
    c=Crange()

    parser = OptionParser("usage: %prog [options] {filename} [clang-args*]")
    parser.add_option("", "--show-ids", dest="showIDs",
                      help="Don't compute cursor IDs (very slow)",
                      default=False)
    parser.add_option("", "--max-depth", dest="maxDepth",
                      help="Limit cursor expansion to depth N",
                      metavar="N", type=int, default=None)
    parser.disable_interspersed_args()
    (c.opts, args) = parser.parse_args()

    if len(args) == 0:
        parser.error('invalid number arguments')

    c.generate(args)
