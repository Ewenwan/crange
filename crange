#!/usr/bin/env python
import sys
import os
import sqlite3
from tabulate import tabulate

from optparse import OptionParser, OptionGroup

class Tag:
    def __init__(self, dbFile='tags.db'):
        self.db = sqlite3.connect(dbFile)
        self.headers = ("Location", "Line", "Kind", "Type", "Spelling", "Display", "USR")
        cursor = self.db.cursor()
        cursor.execute("PRAGMA synchronous = OFF;")
        cursor.execute("PRAGMA journal_mode = MEMORY;")

    def __del__(self):
        self.db.close()
    
    def find(self, name):
        cursor = self.db.cursor()
        cursor.execute("SELECT location, line, kind_name, type_name, spelling, display, usr FROM tags WHERE spelling=?", (name,))
        return cursor.fetchall()
        
    def find_refs(self, name):
        cursor = self.db.cursor()
        cursor.execute("SELECT location, line, kind_name, type_name, spelling, display, ref FROM tags WHERE ref IN (SELECT def FROM tags WHERE spelling=?) AND ref <> '' AND usr='' AND kind_name <> 'UNEXPOSED_EXPR' AND is_def=0", (name,))
        return cursor.fetchall()

    def find_kinds(self):
        cursor = self.db.cursor()
        cursor.execute("SELECT DISTINCT kind_name FROM tags ORDER BY kind_name ASC")
        return cursor.fetchall()
            
    def find_types(self):
        cursor = self.db.cursor()
        cursor.execute("SELECT DISTINCT type_name FROM tags ORDER BY type_name ASC")
        return cursor.fetchall()


class Crange:
    def __init__(self):
        self.tag = Tag()

    def __del__(self):
        pass
                    
    def process(self, opts, args):
        res = ""    
        if opts.tagListKinds:
            res = tabulate(self.tag.find_kinds(), headers=["Kinds"])
        elif opts.tagListTypes:
            res = tabulate(self.tag.find_types(), headers=["Types"])
        elif len(args) > 0:
            if opts.tagRefs:
                res = tabulate(self.tag.find_refs(args[0]), headers=self.tag.headers)
            else:
                res = tabulate(self.tag.find(args[0]), headers=self.tag.headers)
        print "Not found" if (not res or res.isspace()) else res

if __name__ == '__main__':
    parser = OptionParser("usage: %prog [options] identifier")
    parser.add_option("-d", "--database",  dest="database", metavar="DATABASE", type="string", default="tags.db", help="Search for identifiers in database FILE")
    parser.add_option("-b", "--show-body", dest="showBody", default=False, action="store_true", help="Show complete body for the identifier")
    parser.add_option("",   "--list-kinds",dest="tagListKinds", default=False, action="store_true", help="List all identifier kinds present in tag database")
    parser.add_option("-k", "--kind",      dest="tagKind", metavar="KIND", type="string", help="Show identifiers of kind")
    parser.add_option("",   "--list-types",dest="tagListTypes", default=False, action="store_true", help="List all identifier types present in tag database")
    parser.add_option("-t", "--type",      dest="tagType", metavar="TYPE", type="string", help="Show identifiers of type")
    parser.add_option("-r", "--refs",      dest="tagRefs", default=False, action="store_true", help="Show identifier references")
    parser.add_option("-v", "--verbose",   dest="verbose", default=False, action="store_true", help="Enable verbose mode")
    parser.disable_interspersed_args()
    opts, args = parser.parse_args()
    
    if opts.tagListKinds == False and opts.tagListTypes == False and len(args) == 0:
        parser.error('Invalid arguments. Try --help for more information.')

    if not os.path.isfile(opts.database):
        parser.error("%s is not a file" % opts.database)
    else:
        c = Crange()
        c.process(opts, args)
    
